---
title: "demo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# MoNETA: MultiOmics Network Embedding for SubType Analysis

Patient stratification is a critical step in the field of oncology that helps healthcare professionals categorize patients based on specific features related to their cancer. With the advent of advanced technologies in genomics, transcriptomics, proteomics, and other omics fields, it has become increasingly possible to gather multi-omics data from cancer patients, which can provide a comprehensive understanding of the molecular characteristics of the disease.

To harness the power of multi-omics data, a tool for patient stratification using multi-omics data has been developed, called MoNETA. This tool integrates multi-omics data from various sources to create a comprehensive profile of each patient, which can be used to distinguish subtypes of cancer with high accuracy.

# Workflow

Here we describe the workflow of the data integration using MoNETA, which functions can be summarized in:

**1. Preprocessing** **2. Generation of similarity matrix** **3. Dimensionality reduction** **4. Plotting**

## Load package and data

Input data consist of omics matrices with samples on columns and features on rows.

```{r}
library(MoNETA)

load("1_start.RData")

```

## 1. Preprocessing

-   The first step involves normalizing the omics data and removing columns with only 0
-   The matrices are then intersected to obtain a common set of samples

```{r}

Expr_norm <-    normalize_omics(geData)

MUT_norm <-     remove_zeros_cols(MutMatr)
CNV_norm <-     remove_zeros_cols(CNVfunc)

matrices <- list(
    Expr_norm  = Expr_norm,
    MUT_norm   = MUT_norm,
    CNV_norm   = CNV_norm
)

matrices <- get_intersection_matrices(matrices)

```

## 2. Generation of similarity matrix using multi-omics data

-The `k_star_net` function generates a similarity matrix based on the k-nearest neighbors (knn) algorithm, using the vp tree (Vantage Point tree) data structure. This function is used to create a similarity matrix from one of the omics data matrices and returns a network representation of the similarities between the samples in the input matrix.

```{r}

net_list <- list(CNV_norm = k_star_net(matrix = matrices$CNV_norm,
                                       sparsity = .7,
                                       distFun = "Manhattan", cores = 50),
                 Expr_norm = k_star_net(matrix = matrices$Expr_norm,
                                        sparsity = .7,
                                        distFun = "Euclidean", cores = 50),
                 MUT_norm = k_star_net(matrix = matrices$MUT_norm,
                                       sparsity = .1,
                                       distFun = "Manhattan", knn = 10, cores = 50)
)

```

-   The `create_multiplex` function creates a multiplex network, which is a single dataframe, by combining the list of networks that were generated by the `k_star_net` function. This is done by concatenating the individual networks and aggregating their edge weights. The resulting multiplex network represents the relationships between nodes across multiple omics.
-   The `remove_extra_weigth` function removes edges with high weights from the multiplex network. This is done to simplify the network and reduce the amount of noise in the data.
-   The `create_jump_matrix` function creates a single network by merging the omics networks. This is done by combining the individual networks into a single, aggregated network and using it to generate a similarity matrix.

```{r}

multiplex <-  create_multiplex(net_list, weighted = T)

multiplex <-  remove_extra_weigth(multiplex, 1000)

jump_mat  <-  create_jump_matrix(net_list)

```

-   The similarity matrix is generated using the `gen_sim_mat_M` function, which calculates a random walk with restart (RWR) similarity matrix from the jump matrix.

```{r}

RWR_mat   <-  gen_sim_mat_M(network = multiplex,
                         tau = NA, restart = 0.7,
                         jump_neighborhood = F, weighted_multiplex = F, cores = 50)

```

## 3. Dimensionality reduction

-   The similarity matrix generated in step 2 is then used for dimensionality reduction to visualize the relationships between nodes in a lower-dimensional space. In this section, we use four different algorithms to reduce the dimensionality of the similarity matrix:

    -   `get_embedding`: This function uses the MultiVERSE algorithm for multiplex and multiplex-heterogeneous network embedding. MultiVERSE is an algorithm that helps in preserving the graph structure in lower dimensional space

    -   `get_umap_embedding`: This function uses the UMAP (Uniform Manifold Approximation and Projection) algorithm to perform dimensionality reduction

    -   `get_parallel_umap_embedding`: This function uses the parallelized version of umap from the uwot package to perform dimensionality reduction

    -   `get_pca_embedding`: This function uses the Principal Component Analysis (PCA) algorithm to perform dimensionality reduction

```{r}

emb      = get_embedding(RWR_mat, 2, num_steps = 10 ^ 3, cores = 20)

umap_emb = get_umap_embedding(RWR_mat, 2)

pca_emb  = get_pca_embedding(RWR_mat, 2)

ppca_emb = get_parallel_umap_embedding(RWR_mat, 2, n_neighbors = 15, n_threads = 10, n_sgd_threads = 0, grain_size = 1)

```

## 4. Plots

-   The `plot_net` function is used to plot the network representation

```{r}

plot_net(net_list$Expr_norm, anno_df, "EXPR")

```

-   The `plot_umap` and its parallelized version `plot_parallel_umap` functions is used to visualize the results of the UMAP reduction in two dimensions

```{r}

plot_umap(matrix = RWR_mat, nodes_anno = anno_df, id_name = "case_id", interactive = FALSE,
                   id_anno_color = "gender", id_anno_shape = "ethnicity_self_identify", wo_legend = TRUE)

plot_parallel_umap(RWR_mat, anno_df, "case_id", id_anno_color = "ethnicity_self_identify",
                   id_anno_shape = "gender", n_threads = 50, interactive = F)

```

